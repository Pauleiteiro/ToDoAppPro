<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/UI/mainWindow.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/UI/mainWindow.py" />
              <option name="originalContent" value="from PyQt6.QtWidgets import QMainWindow, QLabel, QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QListWidget, QLineEdit, \&#10;    QMessageBox&#10;from database.dbManager import DBManager&#10;from models.task import Task&#10;from notifications.notifier import showNotification&#10;from PyQt6.QtCore import QTimer, QDateTimeEdit&#10;from datetime import datetime, timedelta&#10;from plyer import notification&#10;&#10;class MainWindow(QMainWindow):&#10;    def __init__(self):&#10;        super().__init__()&#10;        self.setWindowTitle(&quot;ToDoAppPro&quot;)&#10;        self.setGeometry(100,100,800,600)&#10;&#10;        self.db = DBManager()&#10;        self.tasks = []&#10;&#10;        # Timer to check notification&#10;        self.notificationTimer = QTimer()&#10;        self.notificationTimer.timeout.connect(self.checkTasknotifications)&#10;        self.notificationTimer.start(60000) # Check every minute&#10;&#10;        # Field for start date&#10;        self.startDateInput = QDateTimeEdit()&#10;        self.startDateInput.setDisplayFormat(&quot;yyyy-MM-dd HH:mm&quot;)&#10;        self.startDateInput.setDateTime(datetime.now())&#10;        # Adiciona ao layout principal&#10;        mainLayout = QVBoxLayout()&#10;        mainLayout.addWidget(self.startDateInput)&#10;&#10;        # Field for due date&#10;        self.dueDateInput = QDateTimeEdit()&#10;        self.dueDateInput.setDisplayFormat(&quot;yyyy-MM-dd HH:mm&quot;)&#10;        self.dueDateInput.setDateTime(datetime.now())&#10;        mainLayout.addWidget(self.dueDateInput)&#10;&#10;        # Show notification of tasks&#10;        showNotification(&quot;Tasks Alert&quot;, &quot;Your tasks are almost out of schedule&quot;)&#10;&#10;        # Initial message&#10;        label = QLabel(&quot;Welcome to ToDoAppPro!&quot;, self)&#10;        label.move(200,200)&#10;&#10;        # Create a central widget&#10;        centralWidget = QWidget()&#10;        self.setCentralWidget(centralWidget)&#10;&#10;        # Main layout&#10;        mainLayout = QVBoxLayout()&#10;        self.setLayout(mainLayout)&#10;&#10;        # Task list&#10;        self.taskList = QListWidget()&#10;        mainLayout.addWidget(self.taskList)&#10;&#10;        # Input field&#10;        self.taskInput = QLineEdit()&#10;        self.taskInput.setPlaceholderText(&quot;Write a new task&quot;)&#10;        mainLayout.addWidget(self.taskInput)&#10;&#10;        # Add task button&#10;        buttonLayout = QHBoxLayout()&#10;        self.addButton = QPushButton(&quot;Add&quot;, self)&#10;        self.removeButton = QPushButton(&quot;Remove&quot;, self)&#10;        buttonLayout.addWidget(self.addButton)&#10;        buttonLayout.addWidget(self.removeButton)&#10;        mainLayout.addLayout(buttonLayout)&#10;&#10;        # Connect buttons to methods&#10;        self.addButton.clicked.connect(self.addTask)&#10;        self.removeButton.clicked.connect(self.removeTask)&#10;&#10;        # Apply layouts&#10;        centralWidget.setLayout(mainLayout)&#10;&#10;        # Carregar tarefas do banco após criar self.taskList&#10;        self.loadTasks()&#10;&#10;    def addTask(self):&#10;        taskText = self.taskInput.text().strip()&#10;&#10;        if taskText:&#10;            task = Task(taskText)&#10;            self.tasks.append(task)&#10;            self.taskList.addItem(str(taskText))&#10;            self.db.addTask(task)&#10;            self.taskInput.clear()&#10;&#10;        else:&#10;            QMessageBox.warning(self, &quot;Input Error&quot;, &quot;Task could not be empty&quot;)&#10;&#10;    def removeTask(self):&#10;        selectedItems = self.taskList.selectedItems()&#10;&#10;        if not selectedItems:&#10;&#10;            QMessageBox.warning(self, &quot;Selection Error&quot;, &quot;Select a task to be removed&quot;)&#10;&#10;            return&#10;&#10;        for item in selectedItems:&#10;            index = self.taskList.row(item)&#10;            task = self.tasks[index]&#10;            self.db.removeTask(task.title)&#10;            self.taskList.takeItem(index)&#10;            del self.tasks[index]&#10;&#10;    def loadTasks(self):&#10;        rows = self.db.loadTasks()&#10;        for row in rows:&#10;            title, description, completed, startDate, dueDate = row&#10;            task = Task(title, description, bool(completed), startDate, dueDate)&#10;            self.tasks.append(task)&#10;            self.taskList.addItem(str(task))&#10;&#10;    def checkTasknotifications(self):&#10;        now = datetime.now()&#10;        for task in self.tasks:&#10;            if task.startDate:&#10;                start = datetime.strptime(task.startDate, &quot;%Y-%m-%d %H:%M&quot;)&#10;&#10;                if now &gt;= start - timedelta(minutes=10) and now &lt; start:&#10;                    notification.notify()&#10;                    title = &quot;Task beginning soon&quot;&#10;                    message = (f&quot;Task is starting soon&quot;)&#10;                    timeout = 10&#10;&#10;                if task.dueDate:&#10;                    due = datetime.strptime(task.dueDate, &quot;%Y-%m-%d %H:%M&quot;)&#10;                    if now &gt;= due - timedelta(minutes=30) and now &lt; due:&#10;                        notification.notify()&#10;                        title = &quot;Task ending soon&quot;&#10;                        message = (f&quot;Task is ending soon&quot;)&#10;                        timeout = 10&#10;" />
              <option name="updatedContent" value="from PyQt6.QtWidgets import QMainWindow, QLabel, QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QListWidget, QLineEdit, \&#10;    QMessageBox, QDateTimeEdit&#10;from database.dbManager import DBManager&#10;from models.task import Task&#10;from notifications.notifier import showNotification&#10;from PyQt6.QtCore import QTimer&#10;from datetime import datetime, timedelta&#10;from plyer import notification&#10;&#10;class MainWindow(QMainWindow):&#10;    def __init__(self):&#10;        super().__init__()&#10;        self.setWindowTitle(&quot;ToDoAppPro&quot;)&#10;        self.setGeometry(100,100,800,600)&#10;&#10;        self.db = DBManager()&#10;        self.tasks = []&#10;&#10;        # Timer to check notification&#10;        self.notificationTimer = QTimer()&#10;        self.notificationTimer.timeout.connect(self.checkTasknotifications)&#10;        self.notificationTimer.start(60000) # Check every minute&#10;&#10;        # Field for start date&#10;        self.startDateInput = QDateTimeEdit()&#10;        self.startDateInput.setDisplayFormat(&quot;yyyy-MM-dd HH:mm&quot;)&#10;        self.startDateInput.setDateTime(datetime.now())&#10;        # Adiciona ao layout principal&#10;        mainLayout = QVBoxLayout()&#10;        mainLayout.addWidget(self.startDateInput)&#10;&#10;        # Field for due date&#10;        self.dueDateInput = QDateTimeEdit()&#10;        self.dueDateInput.setDisplayFormat(&quot;yyyy-MM-dd HH:mm&quot;)&#10;        self.dueDateInput.setDateTime(datetime.now())&#10;        mainLayout.addWidget(self.dueDateInput)&#10;&#10;        # Show notification of tasks&#10;        showNotification(&quot;Tasks Alert&quot;, &quot;Your tasks are almost out of schedule&quot;)&#10;&#10;        # Initial message&#10;        label = QLabel(&quot;Welcome to ToDoAppPro!&quot;, self)&#10;        label.move(200,200)&#10;&#10;        # Create a central widget&#10;        centralWidget = QWidget()&#10;        self.setCentralWidget(centralWidget)&#10;&#10;        # Main layout&#10;        mainLayout = QVBoxLayout()&#10;        self.setLayout(mainLayout)&#10;&#10;        # Task list&#10;        self.taskList = QListWidget()&#10;        mainLayout.addWidget(self.taskList)&#10;&#10;        # Input field&#10;        self.taskInput = QLineEdit()&#10;        self.taskInput.setPlaceholderText(&quot;Write a new task&quot;)&#10;        mainLayout.addWidget(self.taskInput)&#10;&#10;        # Add task button&#10;        buttonLayout = QHBoxLayout()&#10;        self.addButton = QPushButton(&quot;Add&quot;, self)&#10;        self.removeButton = QPushButton(&quot;Remove&quot;, self)&#10;        buttonLayout.addWidget(self.addButton)&#10;        buttonLayout.addWidget(self.removeButton)&#10;        mainLayout.addLayout(buttonLayout)&#10;&#10;        # Connect buttons to methods&#10;        self.addButton.clicked.connect(self.addTask)&#10;        self.removeButton.clicked.connect(self.removeTask)&#10;&#10;        # Apply layouts&#10;        centralWidget.setLayout(mainLayout)&#10;&#10;        # Carregar tarefas do banco após criar self.taskList&#10;        self.loadTasks()&#10;&#10;    def addTask(self):&#10;        taskText = self.taskInput.text().strip()&#10;&#10;        if taskText:&#10;            task = Task(taskText)&#10;            self.tasks.append(task)&#10;            self.taskList.addItem(str(taskText))&#10;            self.db.addTask(task)&#10;            self.taskInput.clear()&#10;&#10;        else:&#10;            QMessageBox.warning(self, &quot;Input Error&quot;, &quot;Task could not be empty&quot;)&#10;&#10;    def removeTask(self):&#10;        selectedItems = self.taskList.selectedItems()&#10;&#10;        if not selectedItems:&#10;&#10;            QMessageBox.warning(self, &quot;Selection Error&quot;, &quot;Select a task to be removed&quot;)&#10;&#10;            return&#10;&#10;        for item in selectedItems:&#10;            index = self.taskList.row(item)&#10;            task = self.tasks[index]&#10;            self.db.removeTask(task.title)&#10;            self.taskList.takeItem(index)&#10;            del self.tasks[index]&#10;&#10;    def loadTasks(self):&#10;        rows = self.db.loadTasks()&#10;        for row in rows:&#10;            title, description, completed, startDate, dueDate = row&#10;            task = Task(title, description, bool(completed), startDate, dueDate)&#10;            self.tasks.append(task)&#10;            self.taskList.addItem(str(task))&#10;&#10;    def checkTasknotifications(self):&#10;        now = datetime.now()&#10;        for task in self.tasks:&#10;            if task.startDate:&#10;                start = datetime.strptime(task.startDate, &quot;%Y-%m-%d %H:%M&quot;)&#10;&#10;                if now &gt;= start - timedelta(minutes=10) and now &lt; start:&#10;                    notification.notify()&#10;                    title = &quot;Task beginning soon&quot;&#10;                    message = (f&quot;Task is starting soon&quot;)&#10;                    timeout = 10&#10;&#10;                if task.dueDate:&#10;                    due = datetime.strptime(task.dueDate, &quot;%Y-%m-%d %H:%M&quot;)&#10;                    if now &gt;= due - timedelta(minutes=30) and now &lt; due:&#10;                        notification.notify()&#10;                        title = &quot;Task ending soon&quot;&#10;                        message = (f&quot;Task is ending soon&quot;)&#10;                        timeout = 10" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/database/dbManager.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/database/dbManager.py" />
              <option name="originalContent" value="import sqlite3&#10;&#10;class DBManager:&#10;    def __init__(self, dbName = &quot;tasks.db&quot;):&#10;&#10;        self.connection = sqlite3.connect(dbName)&#10;&#10;        self.createTable()&#10;&#10;    def createTable(self):&#10;        cursor = self.connection.cursor()&#10;        cursor.execute(&quot;&quot;&quot;CREATE TABLE IF NOT EXISTS tasks (&#10;            id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;            title TEXT NOT NULL,&#10;            description TEXT,&#10;            completed BOOLEAN,,&#10;            startDate TEXT,&#10;            dueDate TEXT&#10;        )&quot;&quot;&quot;)&#10;        self.connection.commit()&#10;&#10;    def addTask(self, task):&#10;        cursor = self.connection.cursor()&#10;        cursor.execute(&quot;&quot;&quot;INSERT INTO tasks (title, description, completed, startDate, dueDate)&#10;        VALUES (?, ?, ?, ?, ?)&quot;&quot;&quot;, (task.title, task.description, bool(task.completed), task.startDate, task.dueDate))&#10;        self.connection.commit()&#10;&#10;&#10;    def removeTask(self, title):&#10;        cursor = self.connection.cursor()&#10;        cursor.execute(&quot;DELETE FROM tasks WHERE title = ?&quot;, (title,))&#10;        self.connection.commit()&#10;&#10;&#10;    def loadTasks(self):&#10;        cursor = self.connection.cursor()&#10;        cursor.execute(&quot;SELECT title,description,completed,startDate,dueDate FROM tasks&quot;)&#10;        rows = cursor.fetchall()&#10;        return rows&#10;" />
              <option name="updatedContent" value="import sqlite3&#10;&#10;class DBManager:&#10;    def __init__(self, dbName = &quot;tasks.db&quot;):&#10;&#10;        self.connection = sqlite3.connect(dbName)&#10;&#10;        self.createTable()&#10;&#10;    def createTable(self):&#10;        cursor = self.connection.cursor()&#10;        cursor.execute(&quot;&quot;&quot;&#10;            CREATE TABLE IF NOT EXISTS tasks (&#10;                id INTEGER PRIMARY KEY AUTOINCREMENT,&#10;                title TEXT NOT NULL,&#10;                description TEXT,&#10;                completed INTEGER,&#10;                startDate TEXT,&#10;                dueDate TEXT&#10;            )&#10;        &quot;&quot;&quot;)&#10;        self.connection.commit()&#10;&#10;    def addTask(self, task):&#10;        cursor = self.connection.cursor()&#10;        cursor.execute(&quot;&quot;&quot;INSERT INTO tasks (title, description, completed, startDate, dueDate)&#10;        VALUES (?, ?, ?, ?, ?)&quot;&quot;&quot;, (task.title, task.description, bool(task.completed), task.startDate, task.dueDate))&#10;        self.connection.commit()&#10;&#10;&#10;    def removeTask(self, title):&#10;        cursor = self.connection.cursor()&#10;        cursor.execute(&quot;DELETE FROM tasks WHERE title = ?&quot;, (title,))&#10;        self.connection.commit()&#10;&#10;&#10;    def loadTasks(self):&#10;        cursor = self.connection.cursor()&#10;        cursor.execute(&quot;SELECT title,description,completed,startDate,dueDate FROM tasks&quot;)&#10;        rows = cursor.fetchall()&#10;        return rows" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>